# Часть 13. JS-селекторы

## С чем Вы познакомитесь

В этом уроке вы познакомитесь с общими концепциями js-селекторами в языке `testo-lang`, а именно:

1. Как с помощью js-селекторов выполнять нетипичные и сложные проверки состояния экрана в действиях `wait` и `check`;
2. Как с помощью js-селекторов перемещать мышку в нужное место, если мощности спецификаторов вам недостаточно.

## Начальные условия

1. Платформа `testo` установлена.
2. Установлен менеджер виртуальных машин `virt-manager`.
3. На хостовой машине имеется прямой (без прокси) доступ в Интернет
4. Имеется установочный образ [Ubuntu Desktop 18.04](https://releases.ubuntu.com/18.04.4/ubuntu-18.04.4-desktop-amd64.iso) с расположением `/opt/iso/ubuntu_desktop.iso`. Местоположение и название установочного файла может быть другим, в этом случае нужно будет соответствующим образом поправить тестовый скрипт.
5. Имеется установочный образ [Ubuntu server 16.04](http://releases.ubuntu.com/16.04/ubuntu-16.04.6-server-amd64.iso) с расположением `/opt/iso/ubuntu_server.iso`. Местоположение и название установочного файла может быть другим, в этом случае нужно будет соответствующим образом поправить тестовый скрипт.
6. (Рекомендовано) Настроена [подсветка синтаксиса](/docs/getting_started/getting_started#настройка-подсветки-языка-testo-lang) `testo-lang` в Sublime Text 3.
7. (Рекомендовано) Проделаны шаги из [десятой части](10_if) и [двенадцатой части](12_mouse)

## Вступление

В предыдущих уроках мы познакомились с действиями `wait`, `check` и `mouse`, и вы могли заметить, что эти действия в большинстве случаев выглядят просто и компактно, но при этом могут при необходимости могут усложняться. Например, если в `wait` вам требуется проверить одновременное наличие нескольких надписей на экране, то можно воспользоваться оператором `&&`, а если в `mouse` требуется передвинуть курсор мышки вправо от надписи на 50 пикселей, то можно воспользоваться спецификаторами `right_center()` и `move_right(50)`.

Но что делать, если стандартных возможностей действий не хватает для необходимых проверок? Например, как проверить. что на экране именно три экземпляра одной надписи? Как передвинуть курсор относительно не одного, а двух объектов на экране? Примеров достаточно сложных проверок и перемещений может быть очень много, и не всегда стандартных встроенных возможностей языка `testo-lang` может хватать для их имплементации.

Для решения этой проблемы в языке `testo-lang` существуют [JS-селекторы](/docs/js/general). Если вкратце - это небольшие участки кода на языке javascript, которые можно применять внутри действий `wait`, `check` и `mouse`. Внутри этих участков кода (js-сниппетов) вы можете получить информацию об объектах на экране и сделать любую сколько угодно сложную обработку содержимого экрана, и при этои результат этой обработки и будет определять результат работы перечисленных действий. И именно с этим механизмом мы познакомимся в этом уроке.

## С чего начать?

Для начала вернёмся к процессу установки Ubuntu Server, который мы уже неоднократно разбирали (и, казалось бы, уже довели до совершенства). Давайте посмотрим на самый первый экран

![Ubuntu Started](/static/tutorials/1_creating_vm/ubuntu_started.png)

Напомним, что при появлении этого экрана мы должны нажать на Enter, потому что нас устраивает английский язык. Но давайте подумаем, а можем ли мы быть на 100% уверенными, что в качестве языка по-умолчанию будет подсвечен именно English? Что если мы сами явлляемся разработчиками Ubuntu Server и мы бы хотели убедиться, что по умолчанию выделен именно английский язык? Что если в этой сборке у нас всё хорошо, а через 10 коммитов какой-нибудь стажер случайно поломает выбор языка по умолчанию и мы бы хотели подстраховаться от такого развития событий?

Возникает вопрос - а существует ли способ удостовериться, что пункт `English` именно **выделена**, а не просто существует на экране? На самом деле, такая возможность в языке `testo-lang` есть, но для этого придется воспользоваться JS-селектором.

Давайте подумаем, а как вообще можно формализовать условие "Надпись выделена"? На самом деле, для этого нам достаточно посмотретьн а цвет надписи и на цвет фона этой надписи. Взгляните внимательно на скриншот. Мы видим, что выделенная надпись отличается от всех остальных в первую очередь тем, что цвет текста на этой надписи белый, а фон - серый, чего не наблюдается на других пунктах с другими языками.

И в плафторме Testo существует возможность анализировать цвета самих надписей и фона этих надписей.

```testo
macro install_ubuntu(hostname, login, password = "${default_password}") {
	start
	wait js "find_text().match('English').match_foreground('white').match_background('gray').size() == 1"
	press Enter
	...
```

Итак, что же мы видим? Во-первых, мы воспользовались новой для нас конструкцией - `wait js`, что означает, что мы хотим дождаться не просто строку, а хотим использовать результат работы JS-селектора. В чем разница? `wait "Надпись"` сработает в том случае, когда на экране появится как минимум один экземпляр искомой надписи. `wait js` сработает тогда, когда javascript-код внутри JS-селектора вернёт значение true. Если в течение заданного таймаута JS-селектор так и не вернул значение true, то действие wait завершится с ошибкой.

Сам JS-селектор должен располагаться в кавычках (если сниппет достаточно длинный, то можно разместить его в нескольких строках, воспользовавшись тройными кавычками). Нам нужно составить сниппет таким образом, чтобы он возвращал true в том случае, если на экране, во-первых, просто есть надпись English, а во-вторых, чтобы эта надпись была черной на сером фоне. Для этого мы воспользуемся доступными встроенными функциями:

1. Чтобы убедиться, что надпись English вообще присутствет на экране, воспользуемся сначала глобальной встроенной функцией [find_text](/docs/js/global_funcs#find_text()), которая вернет нам объект `Tensor<TextLine>`, который содержит информацию о всех найденных надписях на экране.
2. Далее нам необходимо просто отфильтровать лишнюю информацию из полученного `Tensor<TextLine>`, оставив нужные строки. В данном случае нас интересуют все надписи `English`, поэтому мы воспользуемся методом [`match`](/docs/js/tensor_textline#match(value)), передав туда в качестве аргумента строку `English`.
3. Теперь мы имеем объект `Tensor<TextLine>`, содержащий только надписи `English` (в данном случае у нас только одна такая надпись). Нам необходимо проанализировать цвет самой надписи и её фона. Для этого по аналогии мы воспользуемся методами [`match_foreground`](/docs/js/tensor_textline#match_foreground(value)) и [`match_background`](/docs/js/tensor_textline#match_background(value)). В качестве цвета шрифта мы передадим `white`, а цвета фона - `gray`.
4. Если после всех фильтраций мы получим `Tensor<TextLine>` с одной строкой (это можно понять, вызывав метод `size()`), то это будет означать, что на экране действительно присутствует роавно одна выделенная надпись `English`, что нас вполне себе устраивает. Такой сниппет вернет true как только необходимая надпись появится на экране - и `wait` отработает успешно, передав управление следующему действию.

Кстати, использование JS-селекторов в запросах вовсе не означает, что в этом же запросе нельзя пользоваться и обычным поиском надписей. Например, мы могли бы немного усилить проверку содержимого первого экрана, добавив поиск надписи "Language"

```testo
macro install_ubuntu(hostname, login, password = "${default_password}") {
	start
	wait "Language" && js "find_text().match('English').match_foreground('white').match_background('gray').size() == 1"
	press Enter
	...
```

Как вы понимаете, такой `wait` успешно отработает в том случае, если на экране есть надпись `Language` И есть **выделенная** надпись `English`.

Попробуйте запустить тест на установку ОС с изменённым макросом `install_ubuntu` и убедитесь, что он успешно отрабатывает на экране с выбором языка. Попробуйте также поменять в JS-селекторе искомый язык с `English`  на любой другой (например, на Русский) и убедитесь, что теперь `wait` не срабатывает, потому что другие надписи не выделены.

Давайте рассмотрим следующий экран

![How to install](/static/tutorials/2_ubuntu_installation/ubuntu_started_2.png)

В этот раз мы видим, что выделенная надпись отличается от всех остальных только цветом самого текста, а цвет фона не играет никакой роли. Поэтому в этом случае наша проверка будет немного короче:

```testo
macro install_ubuntu(hostname, login, password = "${default_password}") {
	start
	wait js "find_text().match('English').match_foreground('white').match_background('gray').size() == 1"
	press Enter
	wait js "find_text().match('Install Ubuntu Server').match_foreground('white').size() == 1"; press Enter;
	...
```

## Усиливаем проверки при установке Ubuntu Server

Далее мы попадаем на другой экрана выбора языка

![Language](/static/tutorials/13/language.png)

Здесь и далее критерием того, что надпись выделена, является белый шрифт на красном фоне. То есть буквально на каждом экране проверки того, что мы нажимаем именно на то, что ожидаем, будет выглядеть так:

```testo
wait "Choose the language" && js "find_text().match('English').match_foreground('white').match_background('red')size() == 1"; press Enter
...
```

Довольно громоздко, неправда ли? И такие проверки будут присутствовать буквально в каждой строчке нашего тестовго сценария.

Но мы можем решить эту проблему, если воспользуемся уже знакомыми нам макросами и сделаем себе небольшое вспомогательное средство:

```testo
macro enter_if_selected(text) {
	if (check js "find_text().match('${text}').match_foreground('white').match_background('red').size() > 0") {
		press Enter
	} else {
		abort "String ${text} is not selected!"
	}
}
```
Этот новый макрос будет проверять, выделена ли нужна надпись, и если выделена - будет нажимать клавишу Enter - то есть, иными словами - выбирать выделенный пункт. Если же нужна надпись не выделена, то будет генерироваться ошибка.

Теперь повсеместное применение таких проверок уже не будет выглядить так громоздко

```testo
wait "Choose the language";	enter_if_selected("English")
...
```