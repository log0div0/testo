# Часть 14. Циклы

## С чем Вы познакомитесь

В этом уроке вы познакомитесь с циклами в языке `testo-lang`.

## Начальные условия

1. Платформа `testo` установлена.
2. Установлен менеджер виртуальных машин `virt-manager`.
3. На хостовой машине имеется прямой (без прокси) доступ в Интернет
5. Имеется установочный образ [Ubuntu server 16.04](http://releases.ubuntu.com/16.04/ubuntu-16.04.6-server-amd64.iso) с расположением `/opt/iso/ubuntu_server.iso`. Местоположение и название установочного файла может быть другим, в этом случае нужно будет соответствующим образом поправить тестовый скрипт.
6. (Рекомендовано) Настроена [подсветка синтаксиса](/docs/getting_started/getting_started#настройка-подсветки-языка-testo-lang) `testo-lang` в Sublime Text 3.
7. (Рекомендовано) Проделаны шаги из [тринадцатой части](13_js)

## Вступление

Наш цикл ознакомительных уроков с платформой Тесто плавно подходит к своему завершению, и в языке `testo-lang` осталась лишь одна возможность, с которой мы ещё не познакомились - это циклы.

До сих пор мы создавали тестовые сценарии без использования циклов - они нам были ни к чему и скорее бы только мешали. Однако, конечно, рано или поздно вы можете столкнуться с задачей, когда вам потребуется сделать несколько однотипных действий - и в этом случае вам очень пригодятся циклы.

Циклы могут также использоваться и в другом аспекте - при создании вспомогательных макросов по выбору чего-либо на экране когда вы заранее не знаете (или не хотите тратить время чтобы узнать) сколько именно действий вам надо совершить, чтобы дождаться нужного вам события.

Например, давайте посмотрим на уже знакомый нам экран выбора языка при установке Ubuntu Server

![Language](/static/tutorials/13_js/nalguage.png)

Конечно, мы исходили из того, что нам требуется английский язык, и поэтому просто нажимали клавишу Enter, т.к. этот пункт уже выделен по-умолчанию. Но что, если нам требуется другой пункт, например "Русский"? Для этого нам надо 29 раз нажать на клавишу Down, чтобы для начала выделить эту надпись. А что, если мы не хотим считать нужное количество нажатий на клавишу Down? Если мы хотим просто вызвать макрос `select_menu("Русский")` и не беспокоиться о том, сколько раз для этого надо нажимать клавишу вниз? В языке `testo-lang` вы можете создавать такие макросы, и в этом вам помогут циклы, о которых мы сегодня и поговорим.

## С чего начать?

В этом уроке мы попробуем упростить работу в консольном файловом менеджере [Vifm](https://www.tecmint.com/vifm-commandline-based-file-manager-for-linux/) с помощью циклов. Мы выбрали именно этот файловый менеджер потому что его интерфейс больше всего подходит для простого примера применения циклов. При определенном желании вы можете проделать такую же работу и с другими файловыми менеджерами по своему усмотрению.

Для начала давайте почитсим наше дерево тестов от всего ненужного, оставим только одну виртуальную машину, установку гостевых дополнений для неё и установку  менеджера Vifm из репозиртория. В последнем тесте мы будем автоматизировать работу с менеджером Vifm, а пока ограничимся только его запуском.

```testo
test server_install_ubuntu {
	server install_ubuntu("${server_hostname}", "${server_login}")
}

test server_prepare: server_install_ubuntu {
	server {
		install_guest_additions("${server_hostname}", "${server_login}")
		exec bash "apt install -y vifm"
	}
}

test cycles_demo: server_prepare {
	server {
		type "vifm /"; press Enter
		abort "stop here"
	}
}
```

После выполнения этого теста мы увидим интерфейс менеджера Vifm

![Vifm](/static/tutorials/14_for/Vifm.png)

Давайте представим, что нам необходимо зайти в директорию `/usr/sbin`.  Для этого нам нужно сначала 19 раз нажать "Down", затем Enter, затем снова 6 раз Enter, и наконец снова Enter. Напишем это в сценарии

```testo
test cycles_demo: server_prepare {
	server {
		type "vifm /"; press Enter
		sleep 2s

		press Down*19, Enter
		press Down*6, Enter
		abort "stop here"
	}
}
```

Такой скрипт действительно приводит нас к нужному результату 

![usr_sbin](/static/tutorials/14_for/usr_sbin.png)

Но выглядит это всё не очень здорово, не так ли? Здесь есть две глобальные проблемы:

1. Скрипт абсолютно плохо читается - тяжело понять, куда мы хотели бы попасть после того, как спустились вниз на 19 пунктов, а затем снова на 6;
2. Каждый раз высчитывать точное количество нажатий на клавиши вниз-вверх - задача практически невыполнимая, да и бесмыссленная.

На самом деле, решить проблему №1 можно, вспомнив [предыдущий урок](13_js), посвященный JS-селекторам (в частности, определению цвета фона у надписей). В самом деле, мы можем каждый раз осуществлять проверку, что мы выбираем именно тот пункт меню, который нам действительно нужен. Для этого лишь надо формализовать понятие "Выделенный пункт меню". В случае с Vifm выделенная строка отличается от любой другой надписи синим фоном, поэтому давайте вспомним предыдущий урок и модифицируем наш простой тест

```testo
macro vifm_select(menu_entry) {
	if (check js "find_text().match('${menu_entry}').match_background('blue').size() == 1") {
		press Enter
	} else {
		abort "Menu entry ${menu_entry} is not selected"
	}
}

test cycles_demo: server_prepare {
	server {
		type "vifm /"; press Enter
		sleep 2s

		press Down*19; vifm_select("usr")
		press Down*6;  vifm_select("sbin")
		abort "stop here"
	}
}
```

Теперь наш тест выглядит уже немного более читаемым (теперь мы хотя бы можем понять, какой пункт меню мы выбираем), но у нас всё еще остается проблема с тем, что нам придется каждый раз высчитывать точное количество перещёлкиваний Вниз-Вверх чтобы выделить нужный пункт меню. Эту проблему можно исправаить с помощью цикла.

## Цикл для выбора пункта меню

